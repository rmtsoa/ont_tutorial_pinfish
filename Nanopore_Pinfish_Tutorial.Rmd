---
title: "Pinfish tutorial - from Nanopore cDNA sequences to annotated genes"
date: "Report created: `r Sys.Date()`"
output:
  html_document:
    keep_md: yes
    number_sections: yes
    self_contained: yes
    theme: default
    highlight: null
    css: Static/ont_tutorial.css
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: yes
      smooth_scroll: yes
    df_print: paged
link-citations: yes
bibliography: Static/Bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy = FALSE, cache.extra = packageVersion('tufte'))
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(fig.width=9, fig.height=6, warning=FALSE, message=FALSE)

library(digest)
library(ggplot2)
library(knitr)
library(RColorBrewer)
library(tufte)
library(yaml)
library(ShortRead)   # oh the irony!
library(kableExtra) 
library(pdftools)

config <- yaml.load_file("config.yaml")
tutorialText   <- config$tutorialText

##
# the readFastq method from ShortRead does not handle bzip files very well - let´s use the 
# uncompressed file that has been already been unpacked within the required Snakefile
rawData <- file.path(getwd(), "RawData", gsub("(\\.gz$)|(\\.bz2$)", "",config$raw_fastq))

pycData <- file.path(getwd(), "Analysis", "Pychopper", 
                     paste(gsub("(\\.gz$)|(\\.bz2$)", "", config$raw_fastq), "pychop.fastq", sep="."))

slurpContent <- function(filename) {
  include = as.logical(tutorialText)
  if (include) {
    paste(readLines(filename),collapse="\n")
  }
}
```


`r slurpContent("Static/TutorialPreamble.md")`

# Results from **`Pinfish`** analysis Tutorial

## Review of starting sequence collections

# Raw sequence review

It is worth considering some of the sequence characteristics for each of the sequence libraries that has been prepared and included within the differential expression analysis. The statistics shown in the table below \ref{tab:summaryStatsTable} have been produced using the R **`ShortRead`** package (see @R-ShortRead). Loading the provided Fastq format sequence files into computer memory has allowed for the calculation of sequence length distribution, a review of sequence qualities, and the preparation of some minimal statistics that allow for the qualitative and quantitative review of these different sequence libraries. 


```{r startingData, echo=FALSE}
ncalc <- function(len.vector, n) {
  # N50 - length such that scaffolds of this length or longer include half the bases of the assembly
  len.sorted <- rev(sort(len.vector))
  len.sorted[cumsum(len.sorted) >= sum(len.sorted)*n][1]
}


lcalc <- function(len.vector, n) {
  len.sorted <- rev(sort(len.vector))
  which(cumsum(len.sorted) >= sum(len.sorted)*n)[1]
}


processQCFastq <- function(file) {
  fastq <- readFastq(file)
  c(
    reads = formatC(length(fastq), big.mark=","),
    mbs = formatC(round(sum(width(fastq)) / 1000 / 1000, digits=1), big.mark=","),
    min = min(width(fastq)),
    max = max(width(fastq)),
    mean = round(mean(width(fastq)), digits=1),
    median = round(median(width(fastq)), digits=0),
    qval = round(mean(alphabetScore(fastq) / width(fastq)), digits=1),
    gc = round(mean(letterFrequency(sread(fastq), "GC")  / width(fastq)) * 100, digits=1),
    n50 = ncalc(width(fastq), n=0.5),
    l50 = lcalc(width(fastq), n=0.5),
    n90 = ncalc(width(fastq), n=0.9),
    l90 = lcalc(width(fastq), n=0.9)
  )
}

data <- lapply(c(rawData, pycData), processQCFastq)
qcData <- data.frame(data)
colnames(qcData) <- c("RawData", "Pychopper")

```

```{r summaryStatsTable, echo=FALSE, cache=FALSE, resize.width=100}
knitr::kable(qcData, caption="Summary statistics for the cDNA data processed before and after PyChopper filtering", booktabs=TRUE, table.envir='table*', linesep="")  %>%
  kable_styling(latex_options=c("hold_position", font_size=9)) 
```

The summary statistics displayed in the table above include observational metrics including the number of reads, information on the longest, shortest and mean sequence read lengths and other information that includes GC content, N50 and N90 read lengths. The first result column describes the sequence characteristics of the raw sequence collection; the second column describes the sequences following the **`Pychopper`** analysis.

**`Pychopper`** selects for sequence reads that contain the appropriate adapter sequences at each end of the sequence read and will orientate the sequences into the correct or stranded orientation. 

Running **`Pychopper`** on your sequence collection will reduce the total number of reads but will qualitatively increase the utility of the library for isoform discovery. The table above should be reviewed to see how the starting sequence library has been transformed. If too many reads have been removed this could be an indication of problems during library preparation and you would be recommended to discuss your library preparations with a member of our Technical team.



The **`PyChopper`** method used to select for the subset of likely full-length sequence transcripts writes its output to a **`PDF`** file. They key figures from the PDF file are included here.

```{r, results="hide", echo=FALSE}
pychopperPage1 <- pdf_convert("Analysis/Pychopper/Pychopper_report.pdf", pages=1)
pychopperPage2 <- pdf_convert("Analysis/Pychopper/Pychopper_report.pdf", pages=2)
pychopperPage3 <- pdf_convert("Analysis/Pychopper/Pychopper_report.pdf", pages=3)
```

```{r, echo=FALSE, fig.fullwidth=FALSE, message=FALSE}
knitr::include_graphics(pychopperPage1)
```

```{r, echo=FALSE, fig.fullwidth=FALSE, message=FALSE}
knitr::include_graphics(pychopperPage2)
```

```{r, echo=FALSE, fig.fullwidth=FALSE, message=FALSE}
knitr::include_graphics(pychopperPage3)
```


```{r lengthdistribution, include=TRUE, cache=FALSE, echo=FALSE}

# https://stackoverflow.com/questions/6461209/how-to-round-up-to-the-nearest-10-or-100-or-x
roundUpNice <- function(x, nice=seq(from=1, to=10, by=0.25)) {
    if(length(x) != 1) stop("'x' must be of length 1")
    10^floor(log10(x)) * nice[[which(x <= 10^floor(log10(x)) * nice)[[1]]]]
}

fastq <- readFastq(rawData)
sequenceSet <- as.data.frame(cbind(as.character(id(fastq)), width(fastq), alphabetScore(fastq)/width(fastq) ,"Raw"), stringsAsFactors=FALSE)
colnames(sequenceSet) <- c("seqId", "length", "quality", "set")

pycIds <- gsub(".+ ", "", as.character(id(readFastq(pycData))))
sequenceSet[which(sequenceSet$seqId %in% pycIds), "set"] <- "PyChopper"
sequenceSet$length <- as.numeric(sequenceSet$length)
sequenceSet$quality <- as.numeric(sequenceSet$quality)

upperLimit <- roundUpNice(as.numeric(quantile(x=sequenceSet$length, probs=c(0.995))))
histogramBinCount <- 40
breakVal = roundUpNice(upperLimit / histogramBinCount)

breaks <- seq(0, to=upperLimit, by=breakVal)

rawS <- table(cut(subset(sequenceSet, set=="Raw")$length, breaks, include.lowest=TRUE, right=FALSE))
pycS <- table(cut(subset(sequenceSet, set=="PyChopper")$length, breaks, include.lowest=TRUE, right=FALSE))

lengthDist <- data.frame(length=head(breaks, -1), raw=as.vector(rawS), pychop=as.vector(pycS))

lengthDistMelt <- reshape2::melt(lengthDist, id.vars=c("length"))

ggplot(lengthDistMelt, aes(x=length, fill=variable, y=value)) +
  geom_bar(stat="identity") +
  xlab("Read length\n") + ylab("Number of reads\n") +
  scale_fill_manual("Read QC", values=c("raw"=brewer.pal(6, "Paired")[1], "pychop"=brewer.pal(6, "Paired")[2])) +
  scale_x_continuous(limits=c(-breakVal,upperLimit), breaks=pretty(sequenceSet$length,n=40)) +
  labs(title="Histogram showing distribution of read lengths before and after PyChopper filtering", fill="filter")

```


# GFFCompare

The [GFFcompare](https://github.com/gpertea/gffcompare) methods provide a collection of tools that can be used to look for overlapping and novel features within and between genome annotation **`GFF`** files. **`GFFcompare`**  has been run during the **`snakemake`** process. The method was run using the specified GFF genome annotation provided in the config file (``` `r  gsub("(\\.gz$)|(\\.bz2$)", "", gsub(".+/","", config$genome_annot))` ```) and with the following configuration parameters 


* **`-r`**  specifies reference genome
* **`-R`**  causes gffcompare to ignore reference transcripts that are not overlapped by any transcript in input GFF
* **`-M`**  discard (ignore) single-exon transfrags and reference transcripts
* **`-C`**  Discard the “contained” transfrags from the .combined.gtf output. By default, without this option, gffcompare writes in that file isoforms that were found to be fully contained/covered (with the same compatible intron structure)
* **`-K`**  do NOT discard any redundant transfrag matching a reference


```{r, echo=FALSE, comment=""}
cat(paste(readLines("Analysis/GFFcompare/nanopore.stats"),collapse="\n"))
```



Sensitivity = TP / (TP+FN)
Precision = TP / (TP+FP)


.tracking
    1. Query transfrag id
    2. Query locus id
    3. Reference gene id
    4. Reference transcript id
    5. class code
        = complete and exact match of intron chain
        u unknown / intergenic
        c contained in reference (missing exons)
        s intron match but opposite strand (mapping challenge // has pychopper been applied?)
        j multi-exon with junction matches
        o same strand overlap with reference exons
        x exonic overlap but on opposite strand
    6. qJ:<gene_id>|<transcript_id>|<num_exons>|<FPKM>|<TPM>|<cov>|<len>




![](http://ccb.jhu.edu/software/stringtie/gffcompare_codes.png)





# IGV

igv -g ./ReferenceData/Homo_sapiens.GRCh38.dna.primary_assembly.fa  ./Analysis/Minimap2/NA12878-cDNA-1D.chr20.filt.pychopper.bam,./Analysis/Minimap2/polished_reads_aln_sorted.bam,./ReferenceData/Homo_sapiens.GRCh38.94.chromosome.20.gff3,./Analysis/Pinfish/polished_transcripts_collapsed.gff 20:3209488-3223858


# an apparently novel gene from the unfiltered dataset ...



# Glossary of Terms

* __knit__ is the command to render an Rmarkdown file. The knitr package is used to embed code, the results of R analyses and their figures within the typeset text from the document. 

* __L50__  the number of sequences (or contigs etc) that are longer than, or equal to, the N50 length and therefore include half the bases of the assembly

* __N50__  length such that sequences (or contigs etc) of this length or longer include half the bases of the sequence collection

* __Rmarkdown__ is an extension to markdown. Functional R code can be embedded in a plain-text document and subsequently rendered to other formats including the PDF format of this report.

* __QV__  the quality value - -log10(p) that any given base is incorrect. QV may be either at the individual base level, or may be averaged across whole sequences

* __sequencing_summary.txt__ a summary file describing sequence characteristics following base calling with the Guppy / Albacore software.



# Reproducible Research - Produce your own report

This report has been created using **`Rmarkdown`**, publicly available **`R`** packages, and the \LaTeX document typesetting software for reproducibility. For clarity the **`R`** packages used, and their versions, is listed below.

\fontsize{8}{12}

```{r sessionInfo, eval=TRUE, echo=FALSE, comment=NA}
options(width = 100)
utils:::print.sessionInfo(sessionInfo()[-7], locale=FALSE)
```

\fontsize{10}{14}


`r slurpContent("Static/TutorialPostamble.md")`



